<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>funcwc - SSR-First Component Library Demo</title>

    <!-- Base CSS library -->
    <link
      href="https://cdn.jsdelivr.net/npm/ui@1.0.0/dist/ui.min.css"
      rel="stylesheet"
    >

    <!-- HTMX for reactivity -->
    <script src="https://unpkg.com/htmx.org@2.0.6"></script>
    <script src="https://unpkg.com/htmx.org/dist/ext/json-enc.js"></script>

    <!-- CSS theme variables for reactivity -->
    <style>
      :root {
        --theme-mode: light;
        --theme-bg: white;
        --theme-text: #333;
        --theme-accent: #007bff;
      }

      body {
        margin: 0;
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", system-ui,
          sans-serif;
        background: var(--theme-bg);
        color: var(--theme-text);
        transition: background-color 0.3s ease, color 0.3s ease;
      }
    </style>
  </head>
  <body hx-ext="json-enc" hx-encoding="json">
    <!-- Single component - the entire app -->
    <app-layout></app-layout>

    <!-- State manager script for pub/sub reactivity -->
    <script>
      // Minimal state manager for funcwc reactive features
      window.funcwcState = new Map();
      window.funcwcSubscribers = new Map();

      window.funcwc = {
        publishState: (topic, data) => {
          window.funcwcState.set(topic, data);
          const subscribers = window.funcwcSubscribers.get(topic) || [];
          subscribers.forEach((callback) => {
            try {
              callback(data);
            } catch (e) {
              console.warn("funcwc state callback error:", e);
            }
          });
        },

        subscribeToState: (topic, callback) => {
          if (!window.funcwcSubscribers.has(topic)) {
            window.funcwcSubscribers.set(topic, []);
          }
          window.funcwcSubscribers.get(topic).push(callback);

          // Send current state if available
          if (window.funcwcState.has(topic)) {
            callback(window.funcwcState.get(topic));
          }
        },

        getState: (topic) => {
          return window.funcwcState.get(topic);
        },
      };

      // Cart management functions
      window.addToCart = function (
        itemId,
        itemName,
        itemPrice,
        buttonEl,
      ) {
        console.log("Adding to cart:", itemId, itemName, itemPrice);

        let currentCart = window.funcwc?.getState("cart");
        if (!currentCart || !currentCart.items) {
          currentCart = { items: [], total: 0, count: 0 };
        }

        const newItem = {
          id: itemId,
          name: itemName,
          price: itemPrice,
        };
        const existingIndex = currentCart.items.findIndex((item) =>
          item.id === itemId
        );

        if (existingIndex >= 0) {
          currentCart.items[existingIndex].quantity =
            (currentCart.items[existingIndex].quantity || 1) + 1;
        } else {
          currentCart.items.push({ ...newItem, quantity: 1 });
        }

        currentCart.count = currentCart.items.reduce(
          (sum, item) => sum + (item.quantity || 1),
          0,
        );
        currentCart.total = currentCart.items.reduce(
          (sum, item) => sum + (item.price * (item.quantity || 1)),
          0,
        );

        console.log("Publishing cart state:", currentCart);
        window.funcwc?.publishState("cart", currentCart);

        // Visual feedback
        if (buttonEl) {
          const originalText = buttonEl.textContent;
          const originalColor = buttonEl.style.background;
          buttonEl.textContent = "Added!";
          buttonEl.style.background = "#28a745";
          setTimeout(function () {
            buttonEl.textContent = originalText;
            buttonEl.style.background = originalColor;
          }, 1000);
        }
      };

      // Function to set up cart badge subscriptions
      window.setupCartBadges = function () {
        console.log("Setting up cart badges...");

        const cartBadges = document.querySelectorAll(
          ".cart-badge-reactive",
        );
        console.log("Found cart badges:", cartBadges.length);

        cartBadges.forEach((badge) => {
          // Check if already set up to avoid duplicate subscriptions
          if (badge.hasAttribute("data-cart-subscribed")) {
            return;
          }
          badge.setAttribute("data-cart-subscribed", "true");

          console.log("Setting up badge subscription");
          window.funcwc.subscribeToState("cart", function (cartData) {
            console.log("Cart state updated:", cartData);

            const countEl = badge.querySelector(".cart-count");
            const totalEl = badge.querySelector(".cart-total");

            if (countEl) {
              countEl.textContent = cartData.count + " items";
            }
            if (totalEl) {
              totalEl.textContent = "$" + cartData.total.toFixed(2);
            }

            badge.style.transform = "scale(1.05)";
            setTimeout(function () {
              badge.style.transform = "scale(1)";
            }, 200);
          });
        });
      };

      // Set up cart badges when DOM is ready
      document.addEventListener("DOMContentLoaded", function () {
        console.log("DOM loaded, funcwc available:", !!window.funcwc);
        window.setupCartBadges();

        // Test the state manager
        setTimeout(function () {
          console.log("Testing state manager...");
          window.funcwc.publishState("cart", { count: 1, total: 699 });
        }, 2000);
      });

      // Set up cart badges when HTMX content loads
      document.body.addEventListener("htmx:afterSwap", function () {
        console.log("HTMX content loaded, setting up cart badges...");
        window.setupCartBadges();
      });
    </script>
  </body>
</html>
